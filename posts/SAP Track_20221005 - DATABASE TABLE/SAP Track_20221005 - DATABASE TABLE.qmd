---
title: "Co-op SAP Track 20221005 - DATABASE TABLE"
author: "Siyun Min"
date: "2022-10-05"
categories: [SSU, SAP]
---
# 20221005 - DATABASE TABLE

# INTERNAL TABLE 제어

SELECT - 조회

APPEND - 삽입

INSERT - 삽입

MODIFY - 수정/삽입

DELETE - 삭제

# DATABASE TABLE 제어

SELECT - 데이터베이스 테이블에서 데이터를 읽음

INSERT - 데이터베이스 테이블에서 데이터를 추가함

UPDATE - 데이터베이스 테이블의 값을 변경함

MODIFY - 수정/삽업 (INSERT + UPDATE)

- UPDATE - 동일한 키 값이 있는 경우
- INSERT - 동일한 키 값이 존재하지 않는 경우

DELETE - 데이터베이스 테이블의 값을 삭제함

# DATABASE TABLE 제어 - SELECT

SELECT 문은 기본적으로 `SELECT *(field) FROM source INTO target WHERE condition`으로 구성된다.

SELECT field - 조회하고자 하는 테이블 필드명을 나열

FROM - 조회할 테이블을 지정해주고, 위치는 INTO 앞뒤로 다 가능

INTO - 조회에서 읽어온 데이터를 변수에 저장하고, 이 변수를 ABAP 프로그램에서 사용

WHERE - 조회하고자 하는 데이터의 조건

## SELECT field

### Single line

데이터베이스에서 하나의 라인 값을 읽어오고자 할 경우 사용

데이터를 한 건만 가져오기 때문에 원하는 데이터의 조건을 정확히 알고 사용

WHERE 조건이 잘못되어 여러개의 라인을 읽어오면 임의로 라인 반환

```abap
SELECT SINGLE CARRNAME FROM SCARR INTO L_CARRNAME WHERE CARRID = 'AA'
```

### Several lines

데이터베이스에서 여러 라인을 조회

```abap
SELECT CARRNAME FROM SCARR INTO TABLE GT_SCARR WHERE CARRID = 'AA'
```

## FROM

데이터를 조회 할 대상 테이블 (또는 뷰) 지정

하나의 테이블을 지정하거나 여러 개의 테이블을 JOIN 가능

Alias를 사용하여 테이블명에 별명을 붙일 수도 있음

```abap
SELECT * FROM SCARR AS A
```

## INTO

### 구조체 (WORK AREA)

여러 칼럼의 한 라인만 조회할 경우 WORK AREA에 할당

`CORRESPONDING FIELDS OF` 구문을 사용하면 동일 필드명에 값 할당

*기호를 사용하면 전체 칼럼을 조회가능하지만, *은 비효율적

![Untitled](./Untitled.png)

![Untitled](./Untitled%201.png)

![Untitled](./Untitled%202.png)

```abap
DATA: BEGIN OF GS_SCARR,
  CARRNAME LIKE SCARR-CARRNAME,
  CARRID LIKE SCARR-CARRID,
END OF GS_SCARR.
DATA: GT_SCARR LIKE TABLE OF GS_SCARR.

SELECT SINGLE CARRID
  CARRNAME
  FROM SCARR
  INTO ( GS_SCARR-CARRID, GS_SCARR-CARRNAME ).

BREAK-POINT.

WRITE: / GS_SCARR-CARRID, GS_SCARR-CARRNAME.
```

![Untitled](./Untitled%203.png)

![Untitled](./Untitled%204.png)

### INTERAL TABLE

여러 라인을 조회할 경우 INTERNAL TABLE 사용

![Untitled](./Untitled%205.png)

![Untitled](./Untitled%206.png)

![Untitled](./Untitled%207.png)

![Untitled](./Untitled%208.png)

![Untitled](./Untitled%209.png)

```abap
DATA: BEGIN OF GS_SCARR,
  CARRID LIKE SCARR-CARRID,
  CARRNAME LIKE SCARR-CARRNAME,
END OF GS_SCARR.
DATA: GT_SCARR LIKE TABLE OF GS_SCARR.

SELECT CARRID
  CARRNAME
  FROM SCARR
  INTO TABLE GT_SCARR
  WHERE CARRID = 'AA'.

LOOP AT GT_SCARR INTO GS_SCARR.
  WRITE: / GS_SCARR-CARRID, GS_SCARR-CARRNAME.
ENDLOOP.
```

![Untitled](./Untitled%2010.png)

```abap
DATA: BEGIN OF GS_SCARR,
  CARRNAME LIKE SCARR-CARRNAME,
  CARRID LIKE SCARR-CARRID,
END OF GS_SCARR.
DATA: GT_SCARR LIKE TABLE OF GS_SCARR.

SELECT CARRID
  CARRNAME
  FROM SCARR
  INTO TABLE GT_SCARR.

LOOP AT GT_SCARR INTO GS_SCARR.
  WRITE: / GS_SCARR-CARRID, GS_SCARR-CARRNAME.
ENDLOOP.
```

![Untitled](./Untitled%2011.png)

```abap
DATA: BEGIN OF GS_SCARR,
  CARRNAME LIKE SCARR-CARRNAME,
  CARRID LIKE SCARR-CARRID,
END OF GS_SCARR.
DATA: GT_SCARR LIKE TABLE OF GS_SCARR.

SELECT CARRID
  CARRNAME
  FROM SCARR
  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR.

LOOP AT GT_SCARR INTO GS_SCARR.
  WRITE: / GS_SCARR-CARRID, GS_SCARR-CARRNAME.
ENDLOOP.
```

![Untitled](./Untitled%2012.png)

![Untitled](./Untitled%2013.png)

![Untitled](./Untitled%2014.png)

```abap
DATA: BEGIN OF GS_SCARR,
  CARRNAME LIKE SCARR-CARRNAME,
  CARRID LIKE SCARR-CARRID,
END OF GS_SCARR.
DATA: GT_SCARR LIKE TABLE OF GS_SCARR.

SELECT CARRID
  CARRNAME
  FROM SCARR
  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
  WHERE CARRID = 'AA'.

BREAK-POINT.

SELECT CARRID
  CARRNAME
  FROM SCARR
  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
  WHERE CARRID = 'AB'.

BREAK-POINT.
```

![Untitled](./Untitled%2015.png)

![Untitled](./Untitled%2016.png)

```abap
DATA: BEGIN OF GS_SCARR,
  CARRNAME LIKE SCARR-CARRNAME,
  CARRID LIKE SCARR-CARRID,
END OF GS_SCARR.
DATA: GT_SCARR LIKE TABLE OF GS_SCARR.

SELECT CARRID
  CARRNAME
  FROM SCARR
  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
  WHERE CARRID = 'AA'.

BREAK-POINT.

SELECT CARRID
  CARRNAME
  FROM SCARR
  APPENDING CORRESPONDING FIELDS OF TABLE GT_SCARR
  WHERE CARRID = 'AB'.

BREAK-POINT.
```

![Untitled](./Untitled%2017.png)

## WHERE

조회하고자 하는 데이터의 조건

WHERE 조건은 SELECT 적중 수를 줄여주고 사용자가 우너하는 데이터를 정확하게 선택할 수 있도록 하는 조건

WHERE 조건에 사용되는 필드가 인덱스에서 사용될 때 속도 향상 (UPDATE, DELETE에서도 같은 명령어 조건 사용)

### 연산자

EQ: =

NE: <>

LT: <

LE: ≤

GT: >

GE: ≥

### BETWEEN A AND B: INTERVAL 조건

```abap
SELECT * FROM TABLE WHERE FIELD BETWEEN A AND B
```

![Untitled](./Untitled%2018.png)

```abap
DATA: BEGIN OF GS_SCARR,
  ZCHECK TYPE C,
  CARRID LIKE SCARR-CARRID,
  CARRNAME LIKE SCARR-CARRNAME,
END OF GS_SCARR.
DATA: GT_SCARR LIKE TABLE OF GS_SCARR.

SELECT CARRID
  CARRNAME
  FROM SCARR
  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
  WHERE CARRID BETWEEN 'AA' AND 'AB'.

LOOP AT GT_SCARR INTO GS_SCARR.
  WRITE: / GS_SCARR-CARRID, GS_SCARR-CARRNAME.
ENDLOOP.
```

![Untitled](./Untitled%2019.png)

### STRING 비교

문자열 비교할 시 LIKE 구문 사용

```abap
SELECT * FROM TABLE WHERE FIELD LIKE 'A%'
```

![Untitled](./Untitled%2020.png)

```abap
DATA: BEGIN OF GS_SCARR,
  ZCHECK TYPE C,
  CARRID LIKE SCARR-CARRID,
  CARRNAME LIKE SCARR-CARRNAME,
END OF GS_SCARR.
DATA: GT_SCARR LIKE TABLE OF GS_SCARR.

SELECT CARRID
  CARRNAME
  FROM SCARR
  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
  WHERE CARRID LIKE 'A%'.

LOOP AT GT_SCARR INTO GS_SCARR.
  WRITE: / GS_SCARR-CARRID, GS_SCARR-CARRNAME.
ENDLOOP.
```

![Untitled](./Untitled%2021.png)

### LIST VALUE

IN 구문을 사용하여 여러 조건에 속한 경우의 값을 가져온다

```abap
SELECT * FROM TABLE WHERE FIELD IN 조건
```

![Untitled](./Untitled%2022.png)

![Untitled](./Untitled%2023.png)

```abap
DATA: BEGIN OF GS_SCARR,
  ZCHECK TYPE C,
  CARRID LIKE SCARR-CARRID,
  CARRNAME LIKE SCARR-CARRNAME,
END OF GS_SCARR.
DATA: GT_SCARR LIKE TABLE OF GS_SCARR.

SELECT CARRID
  CARRNAME
  FROM SCARR
  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
  WHERE CARRID IN ( 'AA', 'AC' ).

LOOP AT GT_SCARR INTO GS_SCARR.
  WRITE: / GS_SCARR-CARRID, GS_SCARR-CARRNAME.
ENDLOOP.

BREAK-POINT.
```

![Untitled](./Untitled%2024.png)

## RANGE TABLE

### 선언

```abap
RANGES GR_NAME FOR TYPE Reference
```

```abap
DATA: BEGIN OF GR_NAME OCCURS 0,
	SIGN TYPE DDSIGN,
	OPTION TYPE DDOPTION,
	LOW LIKE TYPE Reference,
	HIGH LIKE TYPE Reference,
END OF GR_NAME.
```

![Untitled](./Untitled%2025.png)

### 구조

RANGES 변수를 선언하면 변수는 자동적으로 4개의 필드를 가진 INTERNAL TABLE이 됨

- SIGN
- OPTION
- LOW
- HIGH

![Untitled](./Untitled%2026.png)

![Untitled](./Untitled%2027.png)

![Untitled](./Untitled%2028.png)

![Untitled](./Untitled%2029.png)

```abap
RANGES GR_SCARR FOR SCARR-CARRID.

DATA: BEGIN OF GS_SCARR,
  ZCHECK TYPE C,
  CARRID LIKE SCARR-CARRID,
  CARRNAME LIKE SCARR-CARRNAME,
END OF GS_SCARR.
DATA: GT_SCARR LIKE TABLE OF GS_SCARR.

GR_SCARR-SIGN = 'I'.
GR_SCARR-OPTION = 'EQ'.
GR_SCARR-LOW = 'AA'.
GR_SCARR-HIGH = 'AC'.
APPEND GR_SCARR.

SELECT CARRID
  CARRNAME
  FROM SCARR
  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
  WHERE CARRID IN GR_SCARR.

LOOP AT GT_SCARR INTO GS_SCARR.
  WRITE: / GS_SCARR-CARRID, GS_SCARR-CARRNAME.
ENDLOOP.

BREAK-POINT.
```

![Untitled](./Untitled%2030.png)

![Untitled](./Untitled%2031.png)

![Untitled](./Untitled%2032.png)

```abap
RANGES GR_SCARR FOR SCARR-CARRID.

DATA: BEGIN OF GS_SCARR,
  ZCHECK TYPE C,
  CARRID LIKE SCARR-CARRID,
  CARRNAME LIKE SCARR-CARRNAME,
END OF GS_SCARR.
DATA: GT_SCARR LIKE TABLE OF GS_SCARR.

GR_SCARR-SIGN = 'I'.
GR_SCARR-OPTION = 'BT'.
GR_SCARR-LOW = 'AA'.
GR_SCARR-HIGH = 'AC'.
APPEND GR_SCARR.

SELECT CARRID
  CARRNAME
  FROM SCARR
  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
  WHERE CARRID IN GR_SCARR.

LOOP AT GT_SCARR INTO GS_SCARR.
  WRITE: / GS_SCARR-CARRID, GS_SCARR-CARRNAME.
ENDLOOP.

BREAK-POINT.
```

![Untitled](./Untitled%2033.png)

![Untitled](./Untitled%2034.png)

![Untitled](./Untitled%2035.png)

![Untitled](./Untitled%2036.png)

# In-class practice

![Untitled](./Untitled%2037.png)

```abap
DATA: BEGIN OF GS_ORDER.
  INCLUDE TYPE ZEDU15_001.
  DATA: Z_STATUS_NAME TYPE C LENGTH 10,
        ZZ_STATUS TYPE ZEDU15_002-ZZ_STATUS,
        ZZ_STATUS_NAME TYPE C LENGTH 10,
        ZZ_CODE TYPE ZEDU15_002-ZZ_CODE,
        ZZ_CODE_NAME TYPE C LENGTH 10,
END OF GS_ORDER.
DATA: GT_ORDER LIKE TABLE OF GS_ORDER.

SELECT Z_NUMBER
  ZID
  MATNR
  ZNAME
  Z_SUM
  Z_STATUS
  Z_JDATE
  FROM ZEDU15_001
  INTO CORRESPONDING FIELDS OF TABLE GT_ORDER
  WHERE Z_JDATE BETWEEN '20220901' AND '20220930'.

BREAK-POINT.

RANGES GR_ORDER FOR ZEDU15_001-Z_JDATE.

GR_ORDER-SIGN = 'I'.
GR_ORDER-OPTION = 'BT'.
GR_ORDER-LOW = '20221001'.
GR_ORDER-HIGH = '20221031'.
APPEND GR_ORDER.

SELECT Z_NUMBER
  ZID
  MATNR
  ZNAME
  Z_SUM
  Z_STATUS
  Z_JDATE
  FROM ZEDU15_001
  APPENDING CORRESPONDING FIELDS OF TABLE GT_ORDER
  WHERE Z_JDATE IN GR_ORDER.

BREAK-POINT.

LOOP AT GT_ORDER INTO GS_ORDER.
  IF GS_ORDER-Z_STATUS = '1'.
    SELECT SINGLE ZZ_STATUS FROM ZEDU15_002 INTO CORRESPONDING FIELDS OF GS_ORDER.
  ELSE.
    SELECT SINGLE ZZ_CODE FROM ZEDU15_002 INTO CORRESPONDING FIELDS OF GS_ORDER.
*    WRITE: / GS_ORDER-ZZ_CODE.
  ENDIF.
ENDLOOP.

BREAK-POINT.
```